<!DOCTYPE html>
<meta charset="utf-8">
<title>Graphblast</title>
<style>
@import url(http://fonts.googleapis.com/css?family=Lato:300,400,700);

body {
  font-family: Lato, sans-serif;
}

svg {
  margin: auto;
  position: absolute;
  top: 0; bottom: 0; left: 0; right: 0;
}

rect, text, path, line {
  shape-rendering: crispEdges;
}

text.outside {
  fill: #000;
}

text.inside {
  fill: #fff;
}

.bar {
  fill: #ffa937;
  font-size: 0.9em;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
}
</style>
<body>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>
  // TODO: it might be better to rotate the whole thing, and then individually
  // rotate each piece of text back
  var Orientation = {
    wide: function (data, axisLength, barLength) {
      return {
        axis: {
          orient: 'left',
          transform: ''
        },
        range: {
          x: [0, axisLength - axisLength / data.length],
          y: [0, barLength]
        },
        svg: {width: barLength + 105, height: axisLength + 65},
        label: {
          x: -35,
          y: (axisLength - axisLength / data.length) * 0.5,
          rotate: -90
        },
        translate: function (x, y) {
          return function (d) {
            return ['translate(', 0, ',', x(d.x), ')'].join('');
          };
        },
        bar: {
          x: function (x, y, dx) { return 0; },
          y: function (x, y, dx) { return 1; },
          height: function (x, y, dx) { return Math.max(1, dx - 1); },
          width: function (x, y, dx) {
            return function (d) { return y(d.y); };
          }
        },
        text: {
          x: function (x, y, dx) {
            return function (d) {
              var len = this.getComputedTextLength();
              return y(d.y) > len + 30 ? y(d.y) - 6 - len : y(d.y) + 6;
            };
          },
          y: function (x, y, dx) {
            return dx * 0.5;
          },
          _class: function (x, y, dx) {
            return function (d) {
              var len = this.getComputedTextLength();
              return y(d.y) > len + 30 ? 'inside' : 'outside';
            };
          },
          center: 'dominant-baseline',
        }
      };
    },

    tall: function (data, axisLength, barLength) {
      return {
        axis: {
          orient: 'bottom',
          transform: 'translate(0,' + barLength + ')'
        },
        range: {
          x: [0, axisLength - axisLength / data.length],
          y: [barLength, 0]
        },
        svg: {width: axisLength + 65, height: barLength + 105},
        label: {
          x: (axisLength - axisLength / data.length) * 0.5,
          y: barLength + 50,
          rotate: 0
        },
        translate: function (x, y) {
          return function (d) {
            return ['translate(', x(d.x), ',', y(d.y), ')'].join('');
          };
        },
        bar: {
          x: function (x, y, dx) { return 1; },
          y: function (x, y, dx) { return 0; },
          height: function (x, y, dx) {
            return function (d) { return barLength - y(d.y); };
          },
          width: function (x, y, dx) { return Math.max(1, dx - 1); }
        },
        text: {
          x: function (x, y, dx) {
            return dx * 0.5;
          },
          y: function (x, y, dx) {
            return function (d) {
              return y(d.y) > barLength - 30 ? -6 : 18;
            };
          },
          _class: function (x, y, dx) {
            return function (d) {
              return y(d.y) > barLength - 30 ? 'outside' : 'inside';
            };
          },
          center: 'text-anchor',
        }
      };
    }
  };

  var histogram = function (data, stats, label, wide) {

    if (data.length <= 1) {
      // TODO: don't return, show something
      return;
    }

    // TODO: dynamic with screen resize, underscore debounce?
    var width = 900;
    var height = 500;

    var orient = Orientation[wide ? 'wide' : 'tall'](data, 500, 500);

    var x = d3.scale.linear()
      .domain([d3.min(data, function (d) { return d.x; }),
               d3.max(data, function (d) { return d.x; }) + stats.Bucket])
      .range(orient.range.x);

    var y = d3.scale.linear()
      .domain([0, d3.max(data, function (d) { return d.y; })])
      .range(orient.range.y);

    var axis = d3.svg.axis().scale(x).orient(orient.axis.orient);

    var svg = d3.select('body').append('svg')
      .attr('width', orient.svg.width)
      .attr('height', orient.svg.height)
      .append('g')
      .attr('transform', 'translate(50, 50)');
      // TODO translate amount based on axis width & svg width

    var desc = svg.append('g')
      .attr('transform', 'translate(' + orient.label.x + ',' + orient.label.y + ')')
      .append('text')
      .text(label)
      .attr('class', 'label')
      .attr('text-anchor', 'middle')
      .attr('font-size', '1.1em')
      .attr('font-weight', 'bold')
      .attr('transform', 'rotate(' + orient.label.rotate + ')');

    var bar = svg.selectAll('.bar').data(data)
      .enter()
      .append('g')
      .attr('class', 'bar')
      .attr('transform', orient.translate(x, y ));

    var dx = (x(1) - x(0)) * stats.Bucket;
    bar.append('rect')
      .attr('x', orient.bar.x(x, y, dx))
      .attr('y', orient.bar.y(x, y, dx))
      .attr('height', orient.bar.height(x, y, dx))
      .attr('width', orient.bar.width(x, y, dx))

    bar.append('text')
      .text(function (d) { return d.y; })
      .attr('x', orient.text.x(x, y, dx))
      .attr('y', orient.text.y(x, y, dx))
      .attr('class', orient.text._class(x, y, dx))
      .attr(orient.text.center, 'middle');

    svg.append('g')
      .attr('class', 'axis')
      .attr('transform', orient.axis.transform)
      .call(axis);
  };

var pushHistogram = function (data) {
  var hist = d3.map(data.Histogram).entries().map(function (i) {
      return {x: parseFloat(i.key), y: i.value};
  });
  hist.sort(d3.ascending);
  d3.select('svg').remove();
  histogram(hist, data.Stats, data.Label, data.Wide);
};

var events = new EventSource('/data');
events.onmessage = function (e) {
  var data = JSON.parse(e.data);
  if (data.type && data.type === 'error') {
    // TODO show the error
    return;
  }
  // TODO show EOF, others
  // TODO switch on "histogram" type
  pushHistogram(data);
};

pushHistogram(JSON.parse({{.}}));
</script>
</body>
